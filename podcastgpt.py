#!/usr/bin/env python3
import sys
import openai
import tiktoken
from mutagen.mp3 import MP3 #pip install mutagen
from pydub import AudioSegment #for mp3 manipulation. pip install pydub

#my scripts
from web_scrapt import curate
from summary import outtro
from urlselect import web_search as search
from speech import tts
from bsoundprompt import prompt

#lines below are to add api key as an env variable
import os
from dotenv import load_dotenv, find_dotenv
_ = load_dotenv(find_dotenv())
openai.api_key = os.getenv('OPENAI_API_KEY')

#Font colors
def prRed(skk): print("\033[91m {}\033[00m" .format(skk))
def prGreenIn(skk): input("\033[92m {}\033[00m" .format(skk))

def get_completion_and_token_count(messages, #Here I can count the number of tokens
                                   model="gpt-3.5-turbo-16k-0613", 
                                   temperature=0, 
                                   max_tokens=4096):
    
    response = openai.ChatCompletion.create(
        model=model,
        messages=messages,
        temperature=temperature, 
        max_tokens=max_tokens,
    )
    
    content = response.choices[0].message["content"]
    
    token_dict = {
'prompt_tokens':response['usage']['prompt_tokens'],
'completion_tokens':response['usage']['completion_tokens'],
'total_tokens':response['usage']['total_tokens'],
    }

    return content, token_dict

#n is the number of lines to remove from the top, and m is the number of lines to remove from bottom.
def remove_text(text,n: int,m: int, ts=1):
    # Remove "VERONICA: or Veronica: "
    text = text.replace("VERONICA: ", "")
    text = text.replace("Veronica: ", "")

    # Remove words enclosed in []
    import re
    text = re.sub(r'\[.*?\]', '', text)
    
    # Remove empty lines
    text = "\n".join(line for line in text.split("\n") if line.strip())
    
    if n != 0 or m != 0:
        # Remove the first n lines, and last m lines
        lines = text.split('\n')
        text = '\n'.join(lines[n:-m])

    # Remove empty lines
    text = "\n".join(line for line in text.split("\n") if line.strip())
    
    #Replace \n with ". "
    if ts == 1:
        text = text.replace('\n', '\n<break time="500ms"/>\n')
    
    return text

#Create the file where the output is saved
def save_output(filename: str, texto: str):
    directory = './'

    file_path = os.path.join(directory, filename)

    if not os.path.exists(file_path):
        # File does not exist, create it
        with open(file_path, 'w') as file:
            pass  # This creates an empty file

    with open(file_path, 'a') as file:
        # Append text to the file
        file.write("\n"+texto)
    return f"Content saved to {file_path}."

#It returns Empty when no argument is given to podcastgpt.py
def default():
	print("You missed TOPIC, next episode TOPIC or both.")

def execute():
	entra = sys.argv[1]
	next_ep = sys.argv[2]
	text = f"""Write a script for an episode of a podcast named Your Wellness Journey. The host's name is Veronica, and there are no guests in the podcast. The topic of the episode is {entra}.

Introduction:

- Briefly introduce the podcast and its focus on wellness. It MUST BE MENTIONED that the content and voice are generated by Artificial intelligence.

Part 1 (Around 500 words):

- Introduce the main topic of the episode related to {entra}
- Discuss key points, insights, or strategies related to {entra}.
- Encourage listeners to engage with the content and apply it to their own lives.

Write a script for the Introduction and Part 1. The content should be around 500 words. Remove any last paragraphs that attempt to finish the script. Replace welcome back with just welcome."""
	messages =  [  
	{'role':'system', 
	 'content':"""You are a podcast script writter."""},    
	{'role':'user', 'content':text},  
	] 
	response, token_dict = get_completion_and_token_count(messages, temperature=0)
	
	save_output("raw_p1.txt", response) #for test purpose
	resp1_1 = remove_text(response,0,2,0)  #Part1 for bsoundprompt
	save_output("resp1_1.txt", resp1_1)
	prGreenIn("\nNOW REVIEW THE OUTPUT OF PART 1 IN resp1_1.txt AND PRESS ENTER TO CONTINUE")
	with open('resp1_1.txt', 'r') as file:
		content = file.read()
	resp1_2 = remove_text(content,0,0,1) #Part1 for tts
	resp1_2 = '<speak>\n'+resp1_2+'\n</speak>'
	save_output("resp1_2.txt", resp1_2) #Part1 for tts
	prGreenIn("\nREVIEW resp1_2.txt FOR tts AND PRESS ENTER TO CONTINUE")
	tts(engine="neural", region='ap-northeast-1', endpoint_url='https://polly.ap-northeast-1.amazonaws.com/', output_format='mp3', 
	bucket_name='podcast-wellness-e1', s3_key_prefix='prueba', voice_id='Ruth', text_file_path='./resp1_2.txt', output_path='./part1.mp3')
	audio = MP3("part1.mp3")
	audio_lenght=int(audio.info.length)+6
	prRed(f'\naudio lenght for Part1: {audio_lenght} seconds\n')
	#with open('resp1_1.txt', 'r') as file:
	#	content = file.read()
	prompt1 = prompt(content)
	lines = prompt1.split('\n')
	last_line = lines[-1].strip()
	prRed('\nPrompt to generate Part1 background sound: ')
	print(last_line+"\n")
	#we use the Colab from https://github.com/facebookresearch/audiocraft to generate background audio
	prGreenIn("\nNOW BASED ON THE PROMPT ABOVE, GENERATE BACKGROUND SOUND, NAME IT background1.mp4, AND PRESS ENTER TO CONTINUE") #Need to automate this part
	background1 = AudioSegment.from_file("./background1.mp4", format="mp4")
	background1 = background1 - 22
	background1 = background1 * (int(audio_lenght)+1)
	background1 = background1[0:audio_lenght*1000]
	talk = AudioSegment.from_file("./part1.mp3", format="mp3")
	talk = talk + 8
	overlay1 = background1.overlay(talk, position=3000)
	file_handle = overlay1.export('final_p1.mp3', format='mp3')
	prRed("\nPART 1 IS COMPLETED!")

	#Section 2 picks up any website related to the topic
	url_string = search(entra)
	if len(url_string) == 0:
	    sys.exit("SOMETHING WENT WRONG WITH THE SEARCH FOR TEXT")
	url = url_string[0]['href']
	print("Section 2 web article: "+url)
	intro = "Now in this section of the podcast we will review information we found in a web site."
	part2 = curate(url, entra, intro)
	save_output("tocompare", part2) #for test purpose
	if len(part2) < 100:
	    print("Something went wrong. Check output file!")
	else:
	    print("All seems good!")
	    part2 = remove_text(part2,1,2) #Part2
	save_output("wellness3", part2)

    #Section 3 will pick up a news article
	url_string = search(entra, 'news')
	if len(url_string) == 0:
	    sys.exit("SOMETHING WENT WRONG WITH THE SEARCH FOR NEWS")
	url = url_string[0]['url']
	print("Section 3 news article: "+url)
	intro1 = f"Now in this section of the podcast we will review the news about {entra}"
	part3 = curate(url, entra, intro1)
	save_output("tocompare", part3) #for test purpose
	if len(part3) < 100:
	    print("Something went wrong. Check output file!")
	else:
	    print("All seems good!")
	    part3 = remove_text(part3,1,2) #Part3
	save_output("wellness3", part3)

	#Summary:
	path = "./wellness3"
	with open(path, 'r') as file:
	    content = file.read()
	part4 = outtro(content, next_ep) #here we need to input the topic of the next episode
	save_output("tocompare", part4) #for text purpose
	part4 = remove_text(part4,0,0)    
	save_output("wellness3", part4)
	with open(path, 'r') as file:
	    content = file.read()
	polly = f"<speak>\n{content}\n</speak>"
	save_output("forpolly", polly)
			
def main():
	if len(sys.argv) < 3:	
		default()
	else:
		execute()

if __name__ == "__main__":
	main()
