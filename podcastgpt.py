#!/usr/bin/env python3
import sys
import openai
import tiktoken
from mutagen.mp3 import MP3 #pip install mutagen
from pydub import AudioSegment, silence #for mp3 manipulation. pip install pydub

#my scripts
from web_scrapt import curate
from summary import outtro
from urlselect import web_search as search
from speech import tts
from bsoundprompt import prompt
from audiogen import audio as gen_audio
from filehandle import remove_text, save_output

#lines below are to add api key as an env variable
import os
from dotenv import load_dotenv, find_dotenv
_ = load_dotenv(find_dotenv())
openai.api_key = os.getenv('OPENAI_API_KEY')

#Font colors
def prRed(skk): print("\033[91m {}\033[00m" .format(skk))
def prGreenIn(skk): input("\033[92m {}\033[00m" .format(skk))

def get_completion_and_token_count(messages, #Here I can count the number of tokens
                                   model="gpt-3.5-turbo-16k-0613", 
                                   temperature=0, 
                                   max_tokens=4096):
    
    response = openai.ChatCompletion.create(
        model=model,
        messages=messages,
        temperature=temperature, 
        max_tokens=max_tokens,
    )
    
    content = response.choices[0].message["content"]
    
    token_dict = {
'prompt_tokens':response['usage']['prompt_tokens'],
'completion_tokens':response['usage']['completion_tokens'],
'total_tokens':response['usage']['total_tokens'],
    }

    return content, token_dict

#n is the number of lines to remove from the top, and m is the number of lines to remove from bottom.
#def remove_text(text,n: int,m: int, ts=1):
#    # Remove "VERONICA: or Veronica: "
#    text = text.replace("VERONICA: ", "")
#    text = text.replace("Veronica: ", "")
#
#    # Remove words enclosed in []
#    import re
#    text = re.sub(r'\[.*?\]', '', text)
#    
#    # Remove empty lines
#    text = "\n".join(line for line in text.split("\n") if line.strip())
#    
#    if n != 0 or m != 0:
#        # Remove the first n lines, and last m lines
#        lines = text.split('\n')
#        text = '\n'.join(lines[n:-m])
#
#    # Remove empty lines
#    text = "\n".join(line for line in text.split("\n") if line.strip())
#    
#    #Replace \n with ". "
#    if ts == 1:
#        text = text.replace('\n', '\n<break time="500ms"/>\n')
#    
#    return text

#Create the file where the output is saved
#def save_output(filename: str, texto: str):
#    directory = './'
#
#    file_path = os.path.join(directory, filename)
#
#    if not os.path.exists(file_path):
#        # File does not exist, create it
#        with open(file_path, 'w') as file:
#            pass  # This creates an empty file
#
#    with open(file_path, 'a') as file:
#        # Append text to the file
#        file.write("\n"+texto)
#    return f"Content saved to {file_path}."

#It returns Empty when no argument is given to podcastgpt.py
def default():
	print("You missed TOPIC, next episode TOPIC or both.")

def execute():
	entra = sys.argv[1]
	next_ep = sys.argv[2]
	text = f"""Write a script for an episode of a podcast named Your Wellness Journey. The host's name is Veronica, and there are no guests in the podcast. The topic of the episode is {entra}.

Introduction:

- Briefly introduce the podcast and its focus on wellness. It MUST BE MENTIONED that the content and voice are generated by Artificial intelligence.

Part 1 (Around 500 words):

- Introduce the main topic of the episode related to {entra}
- Discuss key points, insights, or strategies related to {entra}.
- Encourage listeners to engage with the content and apply it to their own lives.

Write a script for the Introduction and Part 1. The content should be around 500 words. Remove any last paragraphs that attempt to finish the script. Replace welcome back with just welcome."""
	messages =  [  
	{'role':'system', 
	 'content':"""You are a podcast script writter."""},    
	{'role':'user', 'content':text},  
	] 
	response, token_dict = get_completion_and_token_count(messages, temperature=0)
	
	save_output("raw.txt", response) #for test purpose
	resp1_1 = remove_text(response,0,0,0)  #Part1 for bsoundprompt
	save_output("resp1_1.txt", resp1_1)
	prGreenIn("\nNOW REVIEW THE OUTPUT OF PART 1 IN resp1_1.txt AND PRESS ENTER TO CONTINUE")
	
	gen_audio("resp1_1.txt", 1)

	#with open('resp1_1.txt', 'r') as file:
	#	content = file.read()
	#resp1_2 = remove_text(content,0,0,1) #Part1 for tts
	#resp1_2 = '<speak>\n'+resp1_2+'\n</speak>'
	#save_output("resp1_2.txt", resp1_2) #Part1 for tts
	#prGreenIn("\nREVIEW resp1_2.txt FOR tts AND PRESS ENTER TO CONTINUE")
	#tts(engine="neural", region='ap-northeast-1', endpoint_url='https://polly.ap-northeast-1.amazonaws.com/', output_format='mp3', 
	#bucket_name='podcast-wellness-e1', s3_key_prefix='prueba', voice_id='Ruth', text_file_path='./resp1_2.txt', output_path='./part1.mp3')
	#audio = MP3("part1.mp3")
	#audio_lenght=int(audio.info.length)+6
	#prRed(f'\naudio lenght for Part1: {audio_lenght} seconds\n')
	##with open('resp1_1.txt', 'r') as file:
	##	content = file.read()
	#prompt1 = prompt(content)
	#lines = prompt1.split('\n')
	#last_two = lines[-2:]
	#last_lines = "\n".join(last_two)
	##last_line = lines[-1].strip()
	#prRed('\nPrompt to generate Part2 background sound: ')
	#print(last_lines+"\n")
	##print(last_line+"\n")
	##we use the Colab from https://github.com/facebookresearch/audiocraft to generate background audio
	#prGreenIn("\nNOW BASED ON THE PROMPT ABOVE, GENERATE BACKGROUND SOUND, NAME IT background1.mp4, AND PRESS ENTER TO CONTINUE") #Need to automate this part
	#background1 = AudioSegment.from_file("./background1.mp4", format="mp4")
	#background1 = background1 - 20
	#background1 = background1 * (int(audio_lenght)+1)
	#background1 = background1[0:audio_lenght*1000]
	#faded_sound = background1.fade_out(3000) #Fade out the background audio the last 3 seconds
	#talk = AudioSegment.from_file("./part1.mp3", format="mp3")
	#talk = talk + 8
	#overlay1 = faded_sound.overlay(talk, position=3000)
	#file_handle = overlay1.export('final_p1.mp3', format='mp3')
	#prRed("\nPART 1 IS COMPLETED!")

	#Section 2 picks up any website related to the topic
	url_string = search(entra)
	if len(url_string) == 0:
	    sys.exit("SOMETHING WENT WRONG WITH THE SEARCH FOR TEXT")
	prRed("\nCheck the articles and chose a good one:")
	for i in range(len(url_string)):
		print(f"URL[{i}]: {url_string[i]['href']}")
	art = input("\nSELECT AN ARTICLE: ")
	art = int(art)
	url = url_string[art]['href']
	print("Section 2 web article: "+url)
	intro = "Now in this section of the podcast we will review information we found in a web site."
	part2 = curate(url, entra, intro)
	save_output("raw.txt", part2) #for test purpose
	if len(part2) < 100:
	    print("Something went wrong. Check output file!")
	else:
	    print("All seems good!")
	    part2 = remove_text(part2,0,0,0) #Part2	
	save_output("resp2_1.txt", part2)
	prGreenIn("\nNOW REVIEW THE OUTPUT OF PART 2 IN resp2_1.txt AND PRESS ENTER TO CONTINUE")

	with open('resp2_1.txt', 'r') as file:
		content = file.read()
	resp2_2 = remove_text(content,0,0,1) #Part2 for tts
	resp2_2 = '<speak>\n'+resp2_2+'\n</speak>'
	save_output("resp2_2.txt", resp2_2) #Part2 for tts
	prGreenIn("\nREVIEW resp2_2.txt FOR tts AND PRESS ENTER TO CONTINUE")
	tts(engine="neural", region='ap-northeast-1', endpoint_url='https://polly.ap-northeast-1.amazonaws.com/', output_format='mp3', 
	bucket_name='podcast-wellness-e1', s3_key_prefix='prueba', voice_id='Ruth', text_file_path='./resp2_2.txt', output_path='./part2.mp3')
	audio = MP3("part2.mp3")
	audio_lenght=int(audio.info.length)+6
	prRed(f'\naudio lenght for Part2: {audio_lenght} seconds\n')
	prompt1 = prompt(content)
	lines = prompt1.split('\n')
	last_two = lines[-2:]
	last_lines = "\n".join(last_two)
	#last_line = lines[-1].strip()
	prRed('\nPrompt to generate Part2 background sound: ')
	print(last_lines+"\n")
	#print(last_line+"\n")
	#we use the Colab from https://github.com/facebookresearch/audiocraft to generate background audio
	prGreenIn("\nNOW BASED ON THE PROMPT ABOVE, GENERATE BACKGROUND SOUND, NAME IT background2.mp4, AND PRESS ENTER TO CONTINUE") #Need to automate this part
	background1 = AudioSegment.from_file("./background2.mp4", format="mp4")
	background1 = background1 - 20
	background1 = background1 * (int(audio_lenght)+1)
	background1 = background1[0:audio_lenght*1000]
	faded_sound = background1.fade_out(3000)
	talk = AudioSegment.from_file("./part2.mp3", format="mp3")
	talk = talk + 8
	overlay1 = faded_sound.overlay(talk, position=3000)
	file_handle = overlay1.export('final_p2.mp3', format='mp3')
	prRed("\nPART 2 IS COMPLETED!")

    #Section 3 will pick up a news article
	url_string = search(entra, 'news')
	if len(url_string) == 0:
	    sys.exit("SOMETHING WENT WRONG WITH THE SEARCH FOR NEWS")
	prRed("\nCheck the news articles and chose a good one:")
	for i in range(len(url_string)):
		print(f"URL[{i}]: {url_string[i]['url']}")
	art = input("\nSELECT A NEWS ARTICLE: ")
	art = int(art)
	url = url_string[art]['url']
	print("Section 3 news article: "+url)
	intro1 = f"Now in this section of the podcast we will review the news about {entra}"
	part3 = curate(url, entra, intro1)
	save_output("raw.txt", part3) #for test purpose
	if len(part3) < 100:
	    print("Something went wrong. Check output file!")
	else:
	    print("All seems good!")
	    part3 = remove_text(part3,0,0,0) #Part3
	save_output("resp3_1.txt", part3)
	prGreenIn("\nNOW REVIEW THE OUTPUT OF PART 3 IN resp3_1.txt AND PRESS ENTER TO CONTINUE")
#SE REPITE
	with open('resp3_1.txt', 'r') as file:
		content = file.read()
	resp3_2 = remove_text(content,0,0,1) #Part3 for tts
	resp3_2 = '<speak>\n'+resp3_2+'\n</speak>'
	save_output("resp3_2.txt", resp3_2) #Part3 for tts
	prGreenIn("\nREVIEW resp3_2.txt FOR tts AND PRESS ENTER TO CONTINUE")
	tts(engine="neural", region='ap-northeast-1', endpoint_url='https://polly.ap-northeast-1.amazonaws.com/', output_format='mp3', 
	bucket_name='podcast-wellness-e1', s3_key_prefix='prueba', voice_id='Ruth', text_file_path='./resp3_2.txt', output_path='./part3.mp3')
	audio = MP3("part3.mp3")
	audio_lenght=int(audio.info.length)+6
	prRed(f'\naudio lenght for Part3: {audio_lenght} seconds\n')
	prompt1 = prompt(content)
	lines = prompt1.split('\n')
	last_two = lines[-2:]
	last_lines = "\n".join(last_two)
	#last_line = lines[-1].strip()
	prRed('\nPrompt to generate Part2 background sound: ')
	print(last_lines+"\n")
	#print(last_line+"\n")
	#we use the Colab from https://github.com/facebookresearch/audiocraft to generate background audio
	prGreenIn("\nNOW BASED ON THE PROMPT ABOVE, GENERATE BACKGROUND SOUND, NAME IT background3.mp4, AND PRESS ENTER TO CONTINUE") #Need to automate this part
	background1 = AudioSegment.from_file("./background3.mp4", format="mp4")
	background1 = background1 - 20
	background1 = background1 * (int(audio_lenght)+1)
	background1 = background1[0:audio_lenght*1000]
	faded_sound = background1.fade_out(3000)
	talk = AudioSegment.from_file("./part3.mp3", format="mp3")
	talk = talk + 8
	overlay1 = faded_sound.overlay(talk, position=3000)
	file_handle = overlay1.export('final_p3.mp3', format='mp3')
	prRed("\nPART 3 IS COMPLETED!")
#HASTA AQUI
	#Summary:
	summ = ''
	for i in range(3):
		path = f'./resp{i+1}_1.txt'
		with open(path, 'r') as file:
			content = file.read()
		summ += content
	part4 = outtro(summ, next_ep) #here we need to input the topic of the next episode
	save_output("resp4_1.txt", part4) #for text purpose
	prGreenIn("\nNOW REVIEW THE OUTPUT OF PART 4 IN resp4_1.txt AND PRESS ENTER TO CONTINUE")
	with open('./resp4_1.txt', 'r') as file:
		content = file.read()	
#SE REPITE
	with open('resp4_1.txt', 'r') as file:
		content = file.read()
	resp4_2 = remove_text(content,0,0,1) #Part4 for tts
	resp4_2 = '<speak>\n'+resp4_2+'\n</speak>'
	save_output("resp4_2.txt", resp4_2) #Part4 for tts
	prGreenIn("\nREVIEW resp4_2.txt FOR tts AND PRESS ENTER TO CONTINUE")
	tts(engine="neural", region='ap-northeast-1', endpoint_url='https://polly.ap-northeast-1.amazonaws.com/', output_format='mp3', 
	bucket_name='podcast-wellness-e1', s3_key_prefix='prueba', voice_id='Ruth', text_file_path='./resp4_2.txt', output_path='./part4.mp3')
	audio = MP3("part4.mp3")
	audio_lenght=int(audio.info.length)+6
	prRed(f'\naudio lenght for Part4: {audio_lenght} seconds\n')
	prompt1 = prompt(content)
	lines = prompt1.split('\n')
	last_two = lines[-2:]
	last_lines = "\n".join(last_two)
	#last_line = lines[-1].strip()
	prRed('\nPrompt to generate Part2 background sound: ')
	print(last_lines+"\n")
	#print(last_line+"\n")
	#we use the Colab from https://github.com/facebookresearch/audiocraft to generate background audio
	prGreenIn("\nNOW BASED ON THE PROMPT ABOVE, GENERATE BACKGROUND SOUND, NAME IT background4.mp4, AND PRESS ENTER TO CONTINUE") #Need to automate this part
	background1 = AudioSegment.from_file("./background4.mp4", format="mp4")
	background1 = background1 - 20
	background1 = background1 * (int(audio_lenght)+1)
	background1 = background1[0:audio_lenght*1000]
	faded_sound = background1.fade_out(3000)
	talk = AudioSegment.from_file("./part4.mp3", format="mp3")
	talk = talk + 8
	overlay1 = faded_sound.overlay(talk, position=3000)
	file_handle = overlay1.export('final_p4.mp3', format='mp3')
	prRed("\nPART 4 IS COMPLETED. I WILL START TO COMBINE AUDIO.")
#HASTA AQUI
	p1 = AudioSegment.from_file("./final_p1.mp3", format="mp3")
	p2 = AudioSegment.from_file("./final_p2.mp3", format="mp3")
	p3 = AudioSegment.from_file("./final_p3.mp3", format="mp3")
	p4 = AudioSegment.from_file("./final_p4.mp3", format="mp3")
	silence_duration = 3000
	silence_segment = AudioSegment.silent(duration=silence_duration)
	combined = p1 + silence_segment + p2 + silence_segment + p3 + silence_segment + p4
	combined.export(f"./{entra}.mp3", format="mp3")
	prRed(f"FIND THE FINAL AUDIO IN ./{entra}.mp3 FILE.")
			
def main():
	if len(sys.argv) < 3:	
		default()
	else:
		execute()

if __name__ == "__main__":
	main()
